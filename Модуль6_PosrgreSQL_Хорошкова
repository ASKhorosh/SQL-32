--=============== МОДУЛЬ 6. POSTGRESQL =======================================
--= ПОМНИТЕ, ЧТО НЕОБХОДИМО УСТАНОВИТЬ ВЕРНОЕ СОЕДИНЕНИЕ И ВЫБРАТЬ СХЕМУ PUBLIC===========
SET search_path TO public;

--======== ОСНОВНАЯ ЧАСТЬ ==============

--ЗАДАНИЕ №1
--Напишите SQL-запрос, который выводит всю информацию о фильмах 
--со специальным атрибутом "Behind the Scenes".

select film_id, title, special_features
from film
where special_features && array['Behind the Scenes']
order by film_id



--ЗАДАНИЕ №2
--Напишите еще 2 варианта поиска фильмов с атрибутом "Behind the Scenes",
--используя другие функции или операторы языка SQL для поиска значения в массиве.

--вариант с any

select film_id, title, special_features
from film
where 'Behind the Scenes' = any (special_features)
order by film_id

--вариант с функцией поиска вхождения

select film_id, title, special_features
from film
where array['Behind the Scenes']<@ array [special_features] 
order by film_id


--ЗАДАНИЕ №3
--Для каждого покупателя посчитайте сколько он брал в аренду фильмов 
--со специальным атрибутом "Behind the Scenes.

--Обязательное условие для выполнения задания: используйте запрос из задания 1, 
--помещенный в CTE. CTE необходимо использовать для решения задания.

with Behind_the_Scenes_films as (
	select film_id, title, special_features
	from film
	where special_features && array['Behind the Scenes']) 
select r.customer_id, count(B.film_id) as count_Behind_the_Scenes_films
from rental r 
join inventory i on i.inventory_id = r.inventory_id 
join Behind_the_Scenes_films B on B.film_id = i.film_id 
group by (r.customer_id)
order by (r.customer_id)


--ЗАДАНИЕ №4
--Для каждого покупателя посчитайте сколько он брал в аренду фильмов
-- со специальным атрибутом "Behind the Scenes".

--Обязательное условие для выполнения задания: используйте запрос из задания 1,
--помещенный в подзапрос, который необходимо использовать для решения задания.


select r.customer_id, count(f.film_id) as count_Behind_the_Scenes_films
from rental r 
join inventory i on i.inventory_id = r.inventory_id 
join film f on i.film_id in (
	select film_id
	from film
	where special_features && array['Behind the Scenes'])
group by (r.customer_id)
order by (r.customer_id)

	

--ЗАДАНИЕ №5
--Создайте материализованное представление с запросом из предыдущего задания
--и напишите запрос для обновления материализованного представления

create  materialized view  
t_count_Behind_the_Scenes_films
as 
select r.customer_id, count(f.film_id) as count_Behind_the_Scenes_films
from rental r 
join inventory i on i.inventory_id = r.inventory_id 
join film f on i.film_id in (
	select film_id
	from film
	where special_features && array['Behind the Scenes'])
group by (r.customer_id)
order by (r.customer_id)
with no data 

refresh  materialized  view  t_count_Behind_the_Scenes_films

--ЗАДАНИЕ №6
--С помощью explain analyze проведите анализ скорости выполнения запросов
-- из предыдущих заданий и ответьте на вопросы:

explain analyze 
select film_id, title, special_features
from film
where special_features && array['Behind the Scenes']
order by film_id
--скрин результата http://joxi.ru/8An1QkpHoR9v92

explain analyze 
select film_id, title, special_features
from film
where 'Behind the Scenes' = any (special_features)
order by film_id
--скрин результата http://joxi.ru/p27p0BbHnxdVXA

explain analyze 
select film_id, title, special_features
from film
where array['Behind the Scenes']<@ array [special_features] 
order by film_id
--скрин результатов http://joxi.ru/eAO8b9RH6aKgBr

--1. Каким оператором или функцией языка SQL, используемых при выполнении домашнего задания, 
--   поиск значения в массиве происходит быстрее
--ОТВЕТ: быстрее всего выполнялся поиск в массиве с помощью any


explain analyze 
with Behind_the_Scenes_films as (
	select film_id, title, special_features
	from film
	where special_features && array['Behind the Scenes']) 
select r.customer_id, count(B.film_id) as count_Behind_the_Scenes_films
from rental r 
join inventory i on i.inventory_id = r.inventory_id 
join Behind_the_Scenes_films B on B.film_id = i.film_id 
group by (r.customer_id)
order by (r.customer_id)
--скрин результата http://joxi.ru/KAgRNaPCN6GB42


explain analyze 
select r.customer_id, count(f.film_id) as count_Behind_the_Scenes_films
from rental r 
join inventory i on i.inventory_id = r.inventory_id 
join film f on i.film_id in (
	select film_id
	from film
	where special_features && array['Behind the Scenes'])
group by (r.customer_id)
order by (r.customer_id)
--скрин результата http://joxi.ru/J2bdkWDCgweDwr

--2. какой вариант вычислений работает быстрее: 
--   с использованием CTE или с использованием подзапроса
--ОТВЕТ: значительно быстрее работает вычисление с использованием CTE





--======== ДОПОЛНИТЕЛЬНАЯ ЧАСТЬ ==============

--ЗАДАНИЕ №1
--Выполняйте это задание в форме ответа на сайте Нетологии

--ЗАДАНИЕ №2
--Используя оконную функцию выведите для каждого сотрудника
--сведения о самой первой продаже этого сотрудника.





--ЗАДАНИЕ №3
--Для каждого магазина определите и выведите одним SQL-запросом следующие аналитические показатели:
-- 1. день, в который арендовали больше всего фильмов (день в формате год-месяц-день)
-- 2. количество фильмов взятых в аренду в этот день
-- 3. день, в который продали фильмов на наименьшую сумму (день в формате год-месяц-день)
-- 4. сумму продажи в этот день




